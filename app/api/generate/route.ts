// app/api/art/route.ts
import OpenAI from "openai";
import { NextResponse } from "next/server";

import { analyzeCode } from "@/lib/analyze";
import { buildHumanParts } from "@/lib/promptParts";

export const runtime = "nodejs";

const client = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

/**
 * Strict QA: detect ANY text / logo-like marks / writing-like strokes.
 * Uses a vision-capable chat model to inspect the generated image and reject if text is present.
 */
async function hasTextArtifacts(openai: OpenAI, dataUrl: string) {
  const resp = await openai.chat.completions.create({
    model: "gpt-4o-mini",
    temperature: 0,
    messages: [
      {
        role: "system",
        content:
          "You are a strict QA checker. Answer ONLY JSON: {has_text:boolean, notes:string}.",
      },
      {
        role: "user",
        content: [
          {
            type: "text",
            text:
              "Check this image for ANY text, letters, numbers, punctuation, glyphs, logo-like marks, signatures, watermarks, stamps, labels, or writing-like strokes. Be strict.",
          },
          { type: "image_url", image_url: { url: dataUrl } },
        ],
      },
    ],
    response_format: { type: "json_object" },
  });

  const raw = resp.choices[0].message.content ?? "{}";
  try {
    const j = JSON.parse(raw);
    return { has_text: Boolean(j.has_text), notes: String(j.notes ?? "") };
  } catch {
    return { has_text: true, notes: "Could not parse QA JSON." };
  }
}
function randomPalette() {
    const colors = [
      ["black"],
      ["black", "olive green"],
      ["deep navy", "pale pink"],
      ["dark brown", "mustard"],
      ["charcoal", "lavender"],
      ["indigo", "ochre"],
      ["forest green", "dusty peach"],
      ["burgundy", "cool grey"],
    ];
  
    const base = ["off-white paper", "warm cream paper", "light grey paper"];
  
    const c = colors[Math.floor(Math.random() * colors.length)];
    const b = base[Math.floor(Math.random() * base.length)];
  
    return `${c.join(" + ")} on ${b}`;
  }
  
export async function POST(req: Request) {
  try {
    if (!process.env.OPENAI_API_KEY) {
      return NextResponse.json(
        { error: "Missing OPENAI_API_KEY in .env.local" },
        { status: 500 }
      );
    }

    const { code, language, chaos } = await req.json();

    // Bound snippet so prompts remain stable + cheap.
    const codeSnippet = String(code ?? "").slice(0, 1800);

    // Analyze structural signals from the code.
    const signals = analyzeCode(codeSnippet);

    // Map signals -> studio-process decisions (human feel)
    const parts = buildHumanParts(signals, Number(chaos ?? 5));

    const palette = randomPalette();
    const prompt = `
    

    A raw experimental abstract artwork that feels made by a human in a studio, not generated by a clean algorithm.

    Tailor the feel to the underlying code via studio-process decisions:
    ${parts.rhythmLine}
    ${parts.layerLine}
    ${parts.recursionLine}
    ${parts.loopLine}
    ${parts.branchLine}
    ${parts.jitterLine}
    ${parts.annotationLine}
    ${parts.densityLine}
    ${parts.chaosLine}

    COLOR (strict limit):
    Use exactly this palette: ${palette}.
    Flat ink fills only.
    No gradients.
    No additional accent colors beyond this palette.

    COMPOSITION:
    All-over composition: activity across the entire canvas (no centered focal, no vignette, no fade-to-edges).
    No empty border region. The pattern remains active right up to all four edges.
    Cropped fragment feel, uneven and imperfect, unresolved in places.

    MARK-MAKING:
    Uneven ink strokes, wobbling hand-drawn lines, smudges, scratches, dry-brush textures, pooled ink, tape lifts, sanded-back zones, ghost impressions.

    SURFACE:
    Matte paper grain, scan noise, slight dirt/dust artifacts.
    No glossy render. No 3D shading. No clean vector look. No polished symmetry.

    PALETTE:
    Charcoal, graphite, raw umber, warm paper tone. Optional subtle rust accent only.
    No bright colors. No neon.

    HARD CONSTRAINTS:
    No text, letters, numbers, punctuation, glyphs, symbols, logos, watermarks, signatures, labels.
    No writing-like strokes. If any text appears, the image is invalid.

    1024x1024.
    `.trim();

    // Generate + reject if text artifacts appear.
    const maxTries = 4;
    let b64: string | undefined;
    const rejected: Array<{ attempt: number; notes: string }> = [];

    for (let attempt = 1; attempt <= maxTries; attempt++) {
      const result = await client.images.generate({
        model: "dall-e-3",
        prompt,
        size: "1024x1024",
        n: 1,
        response_format: "b64_json",
      });

      const candidate = result.data?.[0]?.b64_json;
      if (!candidate) {
        rejected.push({ attempt, notes: "No image returned" });
        continue;
      }

      const dataUrl = `data:image/png;base64,${candidate}`;
      const qa = await hasTextArtifacts(client, dataUrl);

      if (!qa.has_text) {
        b64 = candidate;
        break;
      }

      rejected.push({
        attempt,
        notes: qa.notes || "Text/writing-like artifacts detected",
      });
    }

    if (!b64) {
      return NextResponse.json(
        {
          error: "Could not generate a text-free image after retries.",
          rejected,
          promptUsed: prompt,
          signals: {
            language: String(language ?? ""),
            archetype: parts.archetype,
            branchCount: signals.branchCount,
            loopCount: signals.loopCount,
            tryCatchCount: signals.tryCatchCount,
            indentJitter: signals.indentJitter,
            commentDensity: signals.commentDensity,
            todoCount: signals.todoCount,
            maxLineLen: signals.maxLineLen,
            functionalHints: signals.functionalHints,
            oopHints: signals.oopHints,
            mutationHints: signals.mutationHints,
            recursionHints: signals.recursionHints,
          },
        },
        { status: 500 }
      );
    }

    return NextResponse.json({
      imageDataUrl: `data:image/png;base64,${b64}`,
      promptUsed: prompt,
      rejected,
      signals: {
        language: String(language ?? ""),
        archetype: parts.archetype,
        branchCount: signals.branchCount,
        loopCount: signals.loopCount,
        tryCatchCount: signals.tryCatchCount,
        indentJitter: signals.indentJitter,
        commentDensity: signals.commentDensity,
        todoCount: signals.todoCount,
        maxLineLen: signals.maxLineLen,
        functionalHints: signals.functionalHints,
        oopHints: signals.oopHints,
        mutationHints: signals.mutationHints,
        recursionHints: signals.recursionHints,
      },
    });
  } catch (err: any) {
    console.error(err);
    return NextResponse.json(
      { error: err?.message ?? "Unknown error" },
      { status: 500 }
    );
  }
}
